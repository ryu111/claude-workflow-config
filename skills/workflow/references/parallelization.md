# Parallelization Rules

並行化詳細規則。

## 核心原則

**無依賴的操作必須同時執行**

```
串行 = 浪費時間
並行 = 效率最大化
```

## 並行化決策表

| 操作類型 | 有依賴？ | 處理方式 |
|----------|----------|----------|
| 讀取多個不同檔案 | ❌ 無 | **並行** |
| 搜尋多個不同模式 | ❌ 無 | **並行** |
| 建立多個不同檔案 | ❌ 無 | **並行** |
| 多個獨立任務的 D→R→T | ❌ 無 | **並行啟動多個 Task** |
| Read → Edit 同一檔案 | ✅ 有 | 串行 |
| Write → Bash 執行該檔案 | ✅ 有 | 串行 |
| Task A 的輸出是 Task B 的輸入 | ✅ 有 | 串行 |

## 並行化範例

```python
# ❌ 錯誤：串行執行無依賴操作
Read("file1.py")        # 等待...
Read("file2.py")        # 等待...
Read("file3.py")        # 等待...
# 總時間 = T1 + T2 + T3

# ✅ 正確：並行執行無依賴操作
Read("file1.py")  }
Read("file2.py")  } 同一個訊息，一次發送
Read("file3.py")  }
# 總時間 = max(T1, T2, T3)
```

## 自我檢查

每次執行工具前問自己：

```
□ 我接下來要執行幾個操作？
□ 這些操作之間有依賴關係嗎？
□ 如果沒有依賴，我是否可以一次發送多個工具呼叫？
```

## 紅線規則

發現自己正在串行執行無依賴操作 = 違規！

| 發現自己在... | 正確做法 |
|---------------|----------|
| 連續發送多個 Read 讀取不同檔案 | 停止！改為一次發送 |
| 連續發送多個 Grep 搜尋不同模式 | 停止！改為一次發送 |
| 連續發送多個 Write 建立不同檔案 | 停止！改為一次發送 |
| 串行執行多個獨立任務的 D→R→T | 停止！考慮並行啟動 |
